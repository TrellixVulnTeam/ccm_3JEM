{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport Router from './core/router';\nimport { parseQueryString, filterTrace } from '../utils/common';\nimport mongoose from 'mongoose';\nconst {\n  Block,\n  Transaction\n} = mongoose.models;\nRouter.get('/block', async ({\n  url\n}) => {\n  const param = parseQueryString(url);\n  const ps = parseInt(param.ps) || 10;\n  const pn = parseInt(param.pn) || 1;\n  const block = await Block.find({}).lean(true).sort({\n    number: -1\n  }).skip((pn - 1) * ps).limit(ps);\n  const total = await Block.aggregate([{\n    $group: {\n      _id: null,\n      count: {\n        $sum: 1\n      }\n    }\n  }]);\n  const blockNumber = block[block.length - 1].number;\n  const results = await Transaction.aggregate([{\n    $match: {\n      blockNumber: {\n        $gte: blockNumber\n      }\n    }\n  }, {\n    $group: {\n      _id: '$blockNumber',\n      count: {\n        $sum: 1\n      }\n    }\n  }]);\n  let txns = {};\n  results.forEach(txn => {\n    txns[txn._id] = txn.count;\n  });\n  block.forEach(doc => {\n    doc.txn = txns[doc.number] || 0;\n  });\n  return {\n    rows: block,\n    total: total[0].count\n  };\n});\nRouter.get('/block/{id}', async ({\n  params\n}) => {\n  var _ts$find;\n\n  let results = await Block.findOne({\n    number: params.id\n  });\n  const ts = await Transaction.aggregate([{\n    $match: {\n      blockNumber: {\n        $gte: results.number\n      }\n    }\n  }, {\n    $group: {\n      _id: '$blockNumber',\n      count: {\n        $sum: 1\n      }\n    }\n  }]);\n  const tsNumber = ((_ts$find = ts.find(item => item._id === parseInt(params.id))) === null || _ts$find === void 0 ? void 0 : _ts$find.count) || 0;\n  return _objectSpread({\n    ts: tsNumber\n  }, results._doc);\n});","map":null,"metadata":{},"sourceType":"module"}