{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport Router from './core/router';\nimport { parseQueryString, filterTrace } from '../utils/common';\nimport mongoose from 'mongoose';\nconst {\n  Block,\n  Transaction\n} = mongoose.models;\nRouter.get('/block', async ({\n  url\n}) => {\n  const param = parseQueryString(url);\n  const ps = parseInt(param.ps) || 10;\n  const pn = parseInt(param.pn) || 1;\n  const block = await Block.find({}).lean(true).sort({\n    number: -1\n  }).skip((pn - 1) * ps).limit(ps);\n  const total = await Block.aggregate([{\n    $group: {\n      _id: null,\n      count: {\n        $sum: 1\n      }\n    }\n  }]);\n  const blockNumber = block[block.length - 1].number;\n  const results = await Transaction.aggregate([{\n    $match: {\n      blockNumber: {\n        $gte: blockNumber\n      }\n    }\n  }, {\n    $group: {\n      _id: '$blockNumber',\n      count: {\n        $sum: 1\n      }\n    }\n  }]);\n  let txns = {};\n  results.forEach(txn => {\n    txns[txn._id] = txn.count;\n  });\n  block.forEach(doc => {\n    doc.txn = txns[doc.number] || 0;\n  });\n  return {\n    rows: block,\n    total: total[0].count\n  };\n});\nRouter.get('/block/{id}', async ({\n  params\n}) => {\n  var _ts$find;\n\n  let results = await Block.findOne({\n    number: params.id\n  });\n  const ts = await Transaction.aggregate([{\n    $match: {\n      blockNumber: {\n        $gte: results.number\n      }\n    }\n  }, {\n    $group: {\n      _id: '$blockNumber',\n      count: {\n        $sum: 1\n      }\n    }\n  }]);\n  const tsNumber = ((_ts$find = ts.find(item => item._id === parseInt(params.id))) === null || _ts$find === void 0 ? void 0 : _ts$find.count) || 0;\n  return _objectSpread({\n    ts: tsNumber\n  }, results._doc);\n});","map":{"version":3,"sources":["/Users/libaozhong/cr/ccm-front/api/block.js"],"names":["Router","parseQueryString","filterTrace","mongoose","Block","Transaction","models","get","url","param","ps","parseInt","pn","block","find","lean","sort","number","skip","limit","total","aggregate","$group","_id","count","$sum","blockNumber","length","results","$match","$gte","txns","forEach","txn","doc","rows","params","findOne","id","ts","tsNumber","item","_doc"],"mappings":";;;;;;AAAA,OAAOA,MAAP,MAAmB,eAAnB;AACA,SAASC,gBAAT,EAA2BC,WAA3B,QAA8C,iBAA9C;AACA,OAAOC,QAAP,MAAqB,UAArB;AAEA,MAAM;AAAEC,EAAAA,KAAF;AAASC,EAAAA;AAAT,IAAyBF,QAAQ,CAACG,MAAxC;AAEAN,MAAM,CAACO,GAAP,CAAW,QAAX,EAAqB,OAAO;AAAEC,EAAAA;AAAF,CAAP,KAAmB;AACtC,QAAMC,KAAK,GAAGR,gBAAgB,CAACO,GAAD,CAA9B;AACA,QAAME,EAAE,GAAGC,QAAQ,CAACF,KAAK,CAACC,EAAP,CAAR,IAAsB,EAAjC;AACA,QAAME,EAAE,GAAGD,QAAQ,CAACF,KAAK,CAACG,EAAP,CAAR,IAAsB,CAAjC;AACA,QAAMC,KAAK,GAAG,MAAMT,KAAK,CAACU,IAAN,CAAW,EAAX,EACjBC,IADiB,CACZ,IADY,EAEjBC,IAFiB,CAEZ;AAAEC,IAAAA,MAAM,EAAE,CAAC;AAAX,GAFY,EAGjBC,IAHiB,CAGZ,CAACN,EAAE,GAAG,CAAN,IAAWF,EAHC,EAIjBS,KAJiB,CAIXT,EAJW,CAApB;AAKA,QAAMU,KAAK,GAAG,MAAMhB,KAAK,CAACiB,SAAN,CAAgB,CAAC;AAAEC,IAAAA,MAAM,EAAE;AAAEC,MAAAA,GAAG,EAAE,IAAP;AAAaC,MAAAA,KAAK,EAAE;AAAEC,QAAAA,IAAI,EAAE;AAAR;AAApB;AAAV,GAAD,CAAhB,CAApB;AACA,QAAMC,WAAW,GAAGb,KAAK,CAACA,KAAK,CAACc,MAAN,GAAe,CAAhB,CAAL,CAAwBV,MAA5C;AACA,QAAMW,OAAO,GAAG,MAAMvB,WAAW,CAACgB,SAAZ,CAAsB,CAAC;AAAEQ,IAAAA,MAAM,EAAE;AAAEH,MAAAA,WAAW,EAAE;AAAEI,QAAAA,IAAI,EAAEJ;AAAR;AAAf;AAAV,GAAD,EAAqD;AAAEJ,IAAAA,MAAM,EAAE;AAAEC,MAAAA,GAAG,EAAE,cAAP;AAAuBC,MAAAA,KAAK,EAAE;AAAEC,QAAAA,IAAI,EAAE;AAAR;AAA9B;AAAV,GAArD,CAAtB,CAAtB;AACA,MAAIM,IAAI,GAAG,EAAX;AACAH,EAAAA,OAAO,CAACI,OAAR,CAAiBC,GAAD,IAAS;AACvBF,IAAAA,IAAI,CAACE,GAAG,CAACV,GAAL,CAAJ,GAAgBU,GAAG,CAACT,KAApB;AACD,GAFD;AAGAX,EAAAA,KAAK,CAACmB,OAAN,CAAeE,GAAD,IAAS;AACrBA,IAAAA,GAAG,CAACD,GAAJ,GAAUF,IAAI,CAACG,GAAG,CAACjB,MAAL,CAAJ,IAAoB,CAA9B;AACD,GAFD;AAGA,SAAO;AAAEkB,IAAAA,IAAI,EAAEtB,KAAR;AAAeO,IAAAA,KAAK,EAAEA,KAAK,CAAC,CAAD,CAAL,CAASI;AAA/B,GAAP;AACD,CApBD;AAsBAxB,MAAM,CAACO,GAAP,CAAW,aAAX,EAA0B,OAAO;AAAE6B,EAAAA;AAAF,CAAP,KAAsB;AAAA;;AAC9C,MAAIR,OAAO,GAAG,MAAMxB,KAAK,CAACiC,OAAN,CAAc;AAAEpB,IAAAA,MAAM,EAAEmB,MAAM,CAACE;AAAjB,GAAd,CAApB;AACA,QAAMC,EAAE,GAAG,MAAMlC,WAAW,CAACgB,SAAZ,CAAsB,CAAC;AAAEQ,IAAAA,MAAM,EAAE;AAAEH,MAAAA,WAAW,EAAE;AAAEI,QAAAA,IAAI,EAAEF,OAAO,CAACX;AAAhB;AAAf;AAAV,GAAD,EAAwD;AAAEK,IAAAA,MAAM,EAAE;AAAEC,MAAAA,GAAG,EAAE,cAAP;AAAuBC,MAAAA,KAAK,EAAE;AAAEC,QAAAA,IAAI,EAAE;AAAR;AAA9B;AAAV,GAAxD,CAAtB,CAAjB;AACA,QAAMe,QAAQ,GAAG,aAAAD,EAAE,CAACzB,IAAH,CAAS2B,IAAD,IAAUA,IAAI,CAAClB,GAAL,KAAaZ,QAAQ,CAACyB,MAAM,CAACE,EAAR,CAAvC,uDAAqDd,KAArD,KAA8D,CAA/E;AACA;AAASe,IAAAA,EAAE,EAAEC;AAAb,KAA0BZ,OAAO,CAACc,IAAlC;AACD,CALD","sourcesContent":["import Router from './core/router'\nimport { parseQueryString, filterTrace } from '../utils/common'\nimport mongoose from 'mongoose'\n\nconst { Block, Transaction } = mongoose.models\n\nRouter.get('/block', async ({ url }) => {\n  const param = parseQueryString(url)\n  const ps = parseInt(param.ps) || 10\n  const pn = parseInt(param.pn) || 1\n  const block = await Block.find({})\n    .lean(true)\n    .sort({ number: -1 })\n    .skip((pn - 1) * ps)\n    .limit(ps)\n  const total = await Block.aggregate([{ $group: { _id: null, count: { $sum: 1 } } }])\n  const blockNumber = block[block.length - 1].number\n  const results = await Transaction.aggregate([{ $match: { blockNumber: { $gte: blockNumber } } }, { $group: { _id: '$blockNumber', count: { $sum: 1 } } }])\n  let txns = {}\n  results.forEach((txn) => {\n    txns[txn._id] = txn.count\n  })\n  block.forEach((doc) => {\n    doc.txn = txns[doc.number] || 0\n  })\n  return { rows: block, total: total[0].count }\n})\n\nRouter.get('/block/{id}', async ({ params }) => {\n  let results = await Block.findOne({ number: params.id })\n  const ts = await Transaction.aggregate([{ $match: { blockNumber: { $gte: results.number } } }, { $group: { _id: '$blockNumber', count: { $sum: 1 } } }])\n  const tsNumber = ts.find((item) => item._id === parseInt(params.id))?.count || 0\n  return { ts: tsNumber, ...results._doc }\n})\n"]},"metadata":{},"sourceType":"module"}